<!DOCTYPE html>
<html lang="en">

<head>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-72523215-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-72523215-1');
  </script>

  <title>Two gotchas with scoped and singleton dependencies in ASP.NET Core</title>

  <link rel="stylesheet" href="/styles/styles.css">
  
  <script src="https://kit.fontawesome.com/9b3bcefedf.js" crossorigin="anonymous"></script>
  <script defer src="/scripts/scripts.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js" data-cfasync="false"></script>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css" />

  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">

  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Two possible problems (and their solutions) we can run into when registering objects with various lifecycles with the DI container of ASP.NET Core." />

  <meta property="og:url" content="https://blog.markvincze.com/two-gotchas-with-scoped-and-singleton-dependencies-in-asp-net-core/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Two gotchas with scoped and singleton dependencies in ASP.NET Core" />
  <meta property="og:description" content="Two possible problems (and their solutions) we can run into when registering objects with various lifecycles with the DI container of ASP.NET Core." />
  <meta property="og:site_name" content="Mark Vincze" />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mrkvincze" />
  <meta name="twitter:title" content="Two gotchas with scoped and singleton dependencies in ASP.NET Core" />
  <meta name="twitter:description" content="Two possible problems (and their solutions) we can run into when registering objects with various lifecycles with the DI container of ASP.NET Core." />
  

</head>

<body>
  <div class="navbar-container">
    <nav class="navbar container is-max-desktop" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarMenu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div id="navbarMenu" class="navbar-menu has-text-white-ter">

        <div class="navbar-start">
          
          <a class="navbar-item" href="/">About</a>
          
          <a class="navbar-item" href="/posts">Blog</a>
          
          <a class="navbar-item" href="/projects">Projects</a>
          
          <a class="navbar-item" href="/cv.html">Resume</a>
          
        </div>

        <div class="navbar-end pt-2 ml-2">
          <a class="icon is-medium" href="mailto:hello@markvincze.com" target="_blank">
            <i class="fa fa-lg fa-envelope"></i>
          </a>
          <a class="icon is-medium" href="https://bsky.app/profile/markvincze.com" target="_blank">
            <i class="fab fa-lg fa-bluesky"></i>
          </a>
          <a class="icon is-medium" href="https://twitter.com/mrkvincze" target="_blank">
            <i class="fab fa-lg fa-twitter"></i>
          </a>
          <a class="icon is-medium" href="https://www.github.com/markvincze" target="_blank">
            <i class="fab fa-lg fa-github"></i>
          </a>
          <a class="icon is-medium" href="https://stackoverflow.com/users/974733/mark-vincze" target="_blank">
            <i class="fab fa-lg fa-stack-overflow"></i>
          </a>
          <a class="icon is-medium" href="https://www.linkedin.com/in/markvincze" target="_blank">
            <i class="fab fa-lg fa-linkedin"></i>
          </a>
          <a class="icon is-medium" href="/index.xml" target="_blank">
            <i class="fas fa-lg fa-rss"></i>
          </a>
        </div>
      </div>
    </nav>
  </div>

  <div class="hero-body">
    <div class="container has-text-centered">
      <a href="/">
        <h1 class="title is-2">
          Mark Vincze
        </h1>
      </a>
      <h2 class="subtitle is-5">
        Software Developer
      </h2>
    </div>
  </div>

  

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title is-1">Two gotchas with scoped and singleton dependencies in ASP.NET Core</h1>

    
      


<p class="mb-3 is-vcentered">
  <time class="has-text-grey" datetime="2017-04-17">Apr 17, 2017 &bull;</time>

  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/c%23/">c#</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/asp.net-core/">asp.net-core</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/dependency-injection/">dependency-injection</a>
  

</p>
    

    <article class="content mt-6">
      <p>With ASP.NET Core a new built-in lightweight Dependency Injection framework was introduced in the <code>Microsoft.Extensions.DependencyInjection</code> package, thus in ASP.NET Core applications we don&rsquo;t necessarily need an external library such as Ninject or Unity to do DI, we can simply use the built-in package (whichâ€”although being framework-agnosticâ€”plays really nicely with ASP.NET Core).
Its feature set is rather simple compared to other more full-blown DI frameworks, but it gets the job done in most applications.</p>
<p>When we register our dependencies, we can choose from three different lifecycle settings.</p>
<ul>
<li><strong>Transient</strong>: A new instance of the dependency is going to be created upon every retrieval.</li>
<li><strong>Scoped</strong>: One instance of the dependency is going to be used per scope. In ASP.NET this means that one instance is going to be created per HTTP request. This comes handy if our class depends on some property of the <code>HttpContext</code>.</li>
<li><strong>Singleton</strong>: Only one single instance of the dependency is going to be created and used for all retrievals.</li>
</ul>
<p>I&rsquo;ll introduce two gotchas related to the lifecycle of our dependencies that we can run into, and describe how we can avoid them.</p>
<h1 id="depending-on-a-scoped-dependency-from-a-singleton">Depending on a scoped dependency from a singleton</h1>
<p>If we have a DI graph in which classes with various lifecycles depending on each other, we can run into an issue, that might be tricky to troubleshoot if we don&rsquo;t know where to look for the problem.</p>
<p>Assume the following setup.</p>
<p>We have an <code>IFoo</code> interface registered as a <em>singleton</em>, which depends on <code>IBar</code>, which is registered as <em>scoped</em> (for example because it depends on the current HTTP request).
And from our controller (which we can consider <em>scoped</em>, since it is created per request), we require <code>IFoo</code>.</p>
<p><img src="/images/2017/04/aspnetcore_di_issue.png" alt="Class diagram illustrating the erroneous setup."  style="display:block; margin: auto;" /></p>
<p>The problem with this setup is that the first time we retrieve <code>IFoo</code>, a new instance of <code>Foo</code> and transitively <code>Bar</code> is going to be created. Since <code>Foo</code> is singleton, no new instances of it are going to be created on further retrievals, the single instance created at first will always be retrieved.
But this meansâ€”since the reference to <code>IBar</code> is stored by the instance of <code>Foo</code>â€”that the singleton <code>Foo</code> is going to &ldquo;capture&rdquo; the scoped <code>IBar</code>, so no new instance of <code>Bar</code> is going to be created either, in spite of it being registered as <em>scoped</em>.</p>
<p>This is a bug in our application, since if we retrieve <code>IFoo</code> in a subsequent request, we would need a new instance of <code>IBar</code> to be created, because it might depend on the context of the HTTP request.</p>
<h2 id="example">Example</h2>
<p>Let&rsquo;s illustrate this with an example. We implement an api with MVC, and we want to log some messages, prefixing every log message with the path of the current request.
To do this we define the following interface.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> ISmartLogger
{
    <span style="color:#66d9ef">void</span> Log(<span style="color:#66d9ef">string</span> message);
}
</code></pre></div><p>And write its implementation.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SmartLogger</span> : ISmartLogger
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">string</span> requestPath;

    <span style="color:#66d9ef">public</span> SmartLogger(IHttpContextAccessor httpContextAccessor)
    {
        requestPath = httpContextAccessor?.HttpContext?.Request?.Path.ToString() ?? <span style="color:#e6db74">&#34;No path&#34;</span>;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Log(<span style="color:#66d9ef">string</span> message)
    {
        Console.WriteLine(<span style="color:#e6db74">&#34;{0}: {1}&#34;</span>, requestPath, message);
    }
}
</code></pre></div><p>The implementation is very straightforward. We depend on <code>IHttpContextAccessor</code> to access the <code>HttpContext</code>, and we save the path of the request (if there is any).
(<strong>Note</strong>: of course we don&rsquo;t necessarily have to do this in the constructor, we could retrieve the path on the fly in the <code>Log</code> method, but the approach I&rsquo;ve chosen is important to illustrate the issue.)</p>
<p>Let&rsquo;s say we have a single controller, <code>PeopleController</code>, in which we depend on our <code>ISmartLogger</code>, and log some messages.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a6e22e">[Route(&#34;[controller]</span><span style="color:#e6db74">&#34;)]
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PeopleController</span> : Controller
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ISmartLogger smartLogger;
    
    <span style="color:#66d9ef">public</span> PeopleController(ISmartLogger smartLogger)
    {
        <span style="color:#66d9ef">this</span>.smartLogger = smartLogger;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [HttpGet(&#34;person1&#34;)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Person1()
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Retrieving person 1&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Jane Smith&#34;</span>;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [HttpGet(&#34;person2&#34;)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Person2()
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Retrieving person 2&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;John Doe&#34;</span>;
    }
}
</code></pre></div><p>The last thing we have to do is to register our logger in <code>Startup.ConfigureService()</code>. Since we retrieve the request path in the constructor of our logger, we have to register the service as <em>scoped</em>, so that a new instance is created on every request.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;();
    services.AddScoped&lt;ISmartLogger, SmartLogger&gt;();
}
</code></pre></div><p>If our start up the application and do a couple of requests:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl http://localhost:5000/people/person1
Jane Smith
$ curl http://localhost:5000/people/person2
John Doe
$ curl http://localhost:5000/people/person1
Jane Smith
</code></pre></div><p>Then in the terminal of the web app we can see that our log messages correctly contain the request path.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/people/person1: Retrieving person <span style="color:#ae81ff">1</span>
/people/person2: Retrieving person <span style="color:#ae81ff">2</span>
/people/person1: Retrieving person <span style="color:#ae81ff">1</span>
</code></pre></div><p>So far everything is good. But let&rsquo;s say later we decide to extract the retrieval of the people to a separate service, called <code>PeopleService</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PeopleService</span> : IPeopleService
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ISmartLogger smartLogger;

    <span style="color:#66d9ef">public</span> PeopleService(ISmartLogger smartLogger)
    {
        <span style="color:#66d9ef">this</span>.smartLogger = smartLogger;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> GetPerson1()
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Retrieving person 1&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Jane Smith&#34;</span>;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> GetPerson2()
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Retrieving person 2&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;John Doe&#34;</span>;
    }
}
</code></pre></div><p>And we also change our controller to depend on this service.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#a6e22e">[Route(&#34;[controller]</span><span style="color:#e6db74">&#34;)]
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PeopleController</span> : Controller
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IPeopleService peopleService;

    <span style="color:#66d9ef">public</span> PeopleController(IPeopleService peopleService)
    {
        <span style="color:#66d9ef">this</span>.peopleService = peopleService;
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [HttpGet(&#34;person1&#34;)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Person1()
    {
        <span style="color:#66d9ef">return</span> peopleService.GetPerson1();
    }
<span style="color:#a6e22e">
</span><span style="color:#a6e22e">    [HttpGet(&#34;person2&#34;)]</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> Person2()
    {
        <span style="color:#66d9ef">return</span> peopleService.GetPerson2();
    }
}
</code></pre></div><p>Note that we moved the logging from the controller to the service.
To make this work, we have to also register <code>IPeopleService</code> as a dependency.
Since <code>PeopleService</code> itself is not concerned about the current HTTP request at all, it seems to make sense to register it as a singleton. <strong>This is wrong</strong> and it causes a bug. Let&rsquo;s see what happens if we do this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;();
    services.AddScoped&lt;ISmartLogger, SmartLogger&gt;();
    services.AddSingleton&lt;IPeopleService, PeopleService&gt;();
}
</code></pre></div><p>Now if we start the server and issue the same three requests.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl http://localhost:5000/people/person1
Jane Smith
$ curl http://localhost:5000/people/person2
John Doe
$ curl http://localhost:5000/people/person1
Jane Smith
</code></pre></div><p>Then this is what we&rsquo;ll see in the terminal of the server.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">/people/person1: Retrieving person <span style="color:#ae81ff">1</span>
/people/person1: Retrieving person <span style="color:#ae81ff">2</span>
/people/person1: Retrieving person <span style="color:#ae81ff">1</span>
</code></pre></div><p>Notice that the request path in the second log message is incorrect. The reason for this is that <code>PeopleService</code> is a singleton instance, and it &ldquo;captures&rdquo; the <code>SmartLogger</code> instantiated for the first request, so on all subsequent <code>Log()</code> calls (done from <code>PeopleService</code>) till the end of time, the only request path we&rsquo;ll see in the logs is the one retrieved upon the first request, <code>/people/person1</code>.</p>
<p>The solution is simple, we just have to change the lifecycle of the <code>IPeopleService</code> dependency to be scoped (or transient would also work, but it would do more instantiations than necessary):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp">services.AddScoped&lt;IPeopleService, PeopleService&gt;();
</code></pre></div><p>In general, we must not depend on a transient or scoped dependency (either directly or transitively) from a singleton, and we must not depend on a transient dependency from a scoped object.</p>
<p>In a more complicated application it might seem troublesome to manually look through our whole DI graph to figure out where we might have made this mistake. Luckily in the 2.0 version of ASP.NET Core this is going to be validated by the DI framework, and we&rsquo;ll get an exception if we mess it up (this change cannot be done in the 1.* versions, since it&rsquo;d be a breaking change).</p>
<h1 id="inject-non-singleton-dependencies-into-middlewares">Inject non-singleton dependencies into middlewares</h1>
<p>The second issue I&rsquo;d like to describe can happen when we try to inject a non-singleton dependency into a middleware. Let&rsquo;s see an example right away.</p>
<p>We implement a custom middleware, in which we want to use the previously implemented <code>SmartLogger</code>. We accept <code>ISmartLogger</code> as a constructor parameter.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomMiddleware</span>
{
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ISmartLogger smartLogger;

    <span style="color:#66d9ef">public</span> CustomMiddleware(RequestDelegate next, ISmartLogger smartLogger)
    {
        <span style="color:#66d9ef">this</span>.smartLogger = smartLogger;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task Invoke(HttpContext context)
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Custom middleware called&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Custom response&#34;</span>);
    }
}
</code></pre></div><p>Change <code>Startup.Configure</code> to use this middleware instead of the MVC router.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    app.UseMiddleware&lt;CustomMiddleware&gt;();
    <span style="color:#75715e">// app.UseMvc();
</span><span style="color:#75715e"></span>}
</code></pre></div><p>If we start the server and send two test requests:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ curl http://localhost:5000/foo
Custom response
$ curl http://localhost:5000/bar
Custom response
</code></pre></div><p>We&rsquo;ll see the following output in the terminal of the server.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">No path: Custom middleware called
No path: Custom middleware called
</code></pre></div><p>Something is wrong, since our logger is not printing the path of the requests.
The reason for this is that only one single instance of the middleware gets created, and it&rsquo;s instantiated when the pipeline is set up, prior to the first request, so the <code>HttpContext</code> is not even populated yet.</p>
<p>Since only one instance of the middleware is created, the injection through the constructor is not going to work for dependencies which are not singletons.</p>
<p>We can easily fix this. We can accept dependencies not just in the constructor of the middleware, but also in the <code>Invoke</code> method, so we can fix the problem by modifying the class the following way.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomMiddleware</span>
{
    <span style="color:#66d9ef">public</span> CustomMiddleware(RequestDelegate next)
    {
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task Invoke(HttpContext context, ISmartLogger smartLogger)
    {
        smartLogger.Log(<span style="color:#e6db74">&#34;Custom middleware called&#34;</span>);
        <span style="color:#66d9ef">await</span> context.Response.WriteAsync(<span style="color:#e6db74">&#34;Custom response&#34;</span>);
    }
}
</code></pre></div><p>These two problems are pretty easy to run into, but luckily they are not difficult to fix if you know what to look for. I hope this post we&rsquo;ll save you some time when troubleshooting these DI issues in ASP.NET Core.</p>

    </article>

    
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https:\/\/blog.markvincze.com\/two-gotchas-with-scoped-and-singleton-dependencies-in-asp-net-core\/';
        
        this.page.identifier = 'ghost-35';
        
      };
      (function () { 
        var d = document, s = d.createElement('script');
        s.src = 'https://markvinczeblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  

</section>



  <div style="flex: 1"></div>

  <footer class="footer py-6">
    <div class="content has-text-centered">
      <p>
        Â© 2020 <strong>Mark Vincze</strong>. All rights reserved.<br />
        Built with <a href="https://gohugo.io/">Hugo</a> and <a href="https://bulma.io/">Bulma</a>. ðŸ’™
      </p>
    </div>
  </footer>

</body>

</html>