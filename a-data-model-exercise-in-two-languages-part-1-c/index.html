<!DOCTYPE html>
<html lang="en">

<head>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-72523215-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-72523215-1');
  </script>

  <title>A data model exercise in two languages, part 1: C#</title>

  <link rel="stylesheet" href="/styles/styles.css">
  <script defer src="https://use.fontawesome.com/releases/v5.15.1/js/all.js"></script>
  <script defer src="/scripts/scripts.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js" data-cfasync="false"></script>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css" />

  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="manifest" href="site.webmanifest">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="A simple data model exercise illustrating some challenges we encounter when designing domain models in object oriented programming languages." />
  <meta property="og:url" content="https://blog.markvincze.com/a-data-model-exercise-in-two-languages-part-1-c/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="A data model exercise in two languages, part 1: C#" />
  <meta property="og:description" content="A simple data model exercise illustrating some challenges we encounter when designing domain models in object oriented programming languages." />
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mrkvincze" />
  <meta name="twitter:title" content="A data model exercise in two languages, part 1: C#" />
  <meta name="twitter:description" content="A simple data model exercise illustrating some challenges we encounter when designing domain models in object oriented programming languages." />
  

</head>

<body>
  <div class="navbar-container">
    <nav class="navbar container is-max-desktop" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarMenu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div id="navbarMenu" class="navbar-menu has-text-white-ter">

        <div class="navbar-start">
          
          <a class="navbar-item" href="/">About</a>
          
          <a class="navbar-item" href="/posts">Blog</a>
          
          <a class="navbar-item" href="/projects">Projects</a>
          
        </div>

        <div class="navbar-end pt-2 ml-2">
          <a class="icon is-medium" href="https://twitter.com/mrkvincze" target="_blank">
            <i class="fab fa-lg fa-twitter"></i>
          </a>
          <a class="icon is-medium" href="https://www.github.com/markvincze" target="_blank">
            <i class="fab fa-lg fa-github"></i>
          </a>
          <a class="icon is-medium" href="https://stackoverflow.com/users/974733/mark-vincze" target="_blank">
            <i class="fab fa-lg fa-stack-overflow"></i>
          </a>
          <a class="icon is-medium" href="https://www.linkedin.com/in/markvincze" target="_blank">
            <i class="fab fa-lg fa-linkedin"></i>
          </a>
          <a class="icon is-medium" href="/index.xml" target="_blank">
            <i class="fas fa-lg fa-rss"></i>
          </a>
        </div>
      </div>
    </nav>
  </div>

  <div class="hero-body">
    <div class="container has-text-centered">
      <a href="/">
        <h1 class="title is-2">
          Mark Vincze
        </h1>
      </a>
      <h2 class="subtitle is-5">
        Software Developer
      </h2>
    </div>
  </div>

  

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title is-1">A data model exercise in two languages, part 1: C#</h1>

    
      


<p class="mb-3 is-vcentered">
  <time class="has-text-grey" datetime="2017-05-04">May 4, 2017 &bull;</time>

  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/c%23/">c#</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/computer-science/">computer science</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/f%23/">f#</a>
  

</p>
    

    <article class="content mt-6">
      <h1 id="introduction">Introduction</h1>
<p>When I&rsquo;m learning a new programming language, I usually like to do some coding exercises to get familiar with the various language features, and to get used to the syntax.
Many of these exercises—or <em>katas</em>—are about implementing some kind of algorithm, which is a great way to learn about the control structures of the language, the conditions, loops and functions.
Other katas are more focused on designing a data model for a certain domain, where the goal is to utilize the various features of the type system to create a model as expressive and intuitive as possible.</p>
<p>Since I&rsquo;ve been learning F#, I&rsquo;ve been doing some data modeling exercises to learn what F# type system is capable of. And because I come from a C# background, I often compare my solutions to their C# counterpart, to be able to grasp the differences between the data models used in a functional and an object-oriented language.</p>
<p>In this and the next post I&rsquo;ll take a look at a very simple data modelling exercise: creating a data type representing a card from the <a href="https://en.wikipedia.org/wiki/Standard_52-card_deck">standard 52-card deck</a>. I found this kata simple enough to describe it in detail in a blog post, but it has enough quirks that we can get our teeth into it.<br>
In this first post I&rsquo;ll do it in C#, and in the next one I&rsquo;m going to do the same in F#, where I&rsquo;ll try to contrast how the functional features of F# can solve problems that are cumbersome to express in OO languages.</p>
<h1 id="the-task">The task</h1>
<p>The task I&rsquo;d like to solve in this simple exercise is to design a data model to represent a card in the standard 52-card deck. For now I&rsquo;m only interested in representing one single card, and not a full deck.</p>
<p>We can specify a card with the following points.</p>
<ul>
<li>Every card has a suit (except the Joker), which can be clubs (♣), diamonds (<span style="color: red">♦</span>), hearts (<span style="color: red">♥</span>) and spades (♠).</li>
<li>A card can be either</li>
<li>a card with a number on it between 2 and 10, I&rsquo;ll call this a <em>value card</em>,</li>
<li>or it can be one of the <em>face cards</em>: Jack, Queen, King or Ace.<br>
<em>(Note: the terminology is not 100% unambiguous, some sources don&rsquo;t call the Ace a face card, but I&rsquo;ll consider it as one for the sake of this exercise.)</em></li>
<li>There is a special card, the Joker, which does not have a suit.</li>
</ul>
<p><img src="/images/2017/05/cards.png" alt="Image illustrating the standard 52-card deck."  style="display:block; margin: auto;" /></p>
<p>I would like to implement a data model, which potentially can be used by multiple different algorithms. More concretely, let&rsquo;s imagine that we deliver the data model in a self-contained package, and then we can implement the logic necessary to model various card games, which all depend on this single data model.<br>
What this means in practice is that I would not like to mix data and logic in our data types, but rather just focus on the data. This might be different than what encapsulation in OO would suggest, but it&rsquo;s necessary if we want to have a data model which then can be used in several different algorithms (which is a typical practice in functional programming).</p>
<h1 id="implementing-in-c35">Implementing in C#</h1>
<p>When we start to implement this data model in C#, it seems intuitive that we&rsquo;ll probably need an enum for the suit of a card.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">enum</span> Suit
{
    Clubs,
    Hearts,
    Diamonds,
    Spades
}
</code></pre></div><p>Similarly, I&rsquo;ll creat an enum type for the different kind of face types.<br>
(It&rsquo;s debatable whether Ace is considered a face card or not, in this model I&rsquo;ll assume that it is.)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">enum</span> Face
{
    Jack,
    Queen,
    King,
    Ace
}
</code></pre></div><p>With these in place I can create the actual type representing a card in the deck. I&rsquo;ll add a <code>Suit</code>, a <code>Face</code> and a <code>Value</code> property, saying that a card is either a face card or a value card, so that only one of those properties will have a value at any given time.<br>
Since these are represented with value types, we have to make them nullable to be able to say they might not have a value. I also added a constructor.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> Suit Suit { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> Face? Face { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int?</span> Value { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> Card(Suit suit, Face? face, <span style="color:#66d9ef">int?</span> <span style="color:#66d9ef">value</span>)
    {
        Suit = suit;
        Face = face;
        Value = <span style="color:#66d9ef">value</span>;
    }
}
</code></pre></div><p>This type seems to be covering our requirements, since any card of the deck can be represented with an instance of it.</p>
<h2 id="avoid-invalid-states-à-la-ddd">Avoid invalid states (à la DDD)</h2>
<p>We cannot be completely satisfied yet: this data model violates an important guideline of domain-driven design (and just generally an all-around good practice): <strong>Design our data model in a way that illegal states are not representable</strong>.<br>
This is beneficial for two main reasons.</p>
<ul>
<li>It helps avoiding bugs we would bump into due to invalid data.</li>
<li>It makes implementing any sort of validation logic easier, since (at least some of) the validity of our data is immediately enforced by our data model.</li>
</ul>
<p>Our current model doesn&rsquo;t satisfy this requirement, since we&rsquo;re able to do this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> card = <span style="color:#66d9ef">new</span> Card(Suit.Clubs, Face.Jack, <span style="color:#ae81ff">5</span>);
</code></pre></div><p>Since this card instance will have both of its <code>Face</code> and <code>Value</code> property set, we will have no way deciding what it actually represent. We should not allow an instance like this to be created.</p>
<p>This can be nicely solved by a simple C# pattern I like to call the <em>Factory method pattern</em>. (Note: you might find other sources using the same term to denote a slightly more complicated pattern.)<br>
We can make our constructor private, and introduce designated public methods (the <em>factory methods</em>) for creating instances of various kinds. Since the constructor is not accessible from the outside, we just have to make sure that our factory methods initialize the instance in a way that it represents a valid value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> Suit Suit { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> Face? Face { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int?</span> Value { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }

    <span style="color:#66d9ef">private</span> Card(Suit suit, Face? face, <span style="color:#66d9ef">int?</span> <span style="color:#66d9ef">value</span>)
    {
        Suit = suit;
        Face = face;
        Value = <span style="color:#66d9ef">value</span>;
    }
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Card CreateFace(Suit suit, Face face)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Card(suit, face, <span style="color:#66d9ef">null</span>);
    }
    
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Card CreateValue(Suit suit, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span>)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Card(suit, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">value</span>);
    }
}
</code></pre></div><p>Better, now we cannot use the constructor from outside, we have to use one of the two factory methods, thereby enforcing us to create only valid instances.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> card = Card.CreateFace(Suit.Clubs, Face.Jack);
</code></pre></div><p>I use this pattern all the time, not just to enforce some preconditions, but also to make code more self-documenting by introducing these expressive method names for object creation.</p>
<h2 id="mutability">Mutability</h2>
<p>Of course we have a glaring problem: since our properties have public setters, there is nothing stopping us from creating a correct instance with the factory methods, but then mutate the instance afterwards to make it invalid.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">var</span> invalid = Card.CreateFace(Suit.Clubs, Face.Jack);
invalid.Value = <span style="color:#ae81ff">5</span>;
</code></pre></div><p>This is easy to mitigate, just remove the setters to make our type immutable (which is beneficial to strive for anyway).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> Suit Suit { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> Face? Face { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int?</span> Value { <span style="color:#66d9ef">get</span>; }

    ...
}
</code></pre></div><p>(This is something that I could&rsquo;ve done immediately, but I wanted to illustrate the thought process that often happens during implementing a data model in C#, where—not to be condescending, just based on my experience—not necessarily every developer thinks about mutability consciously.)</p>
<h2 id="finishing-up">Finishing up</h2>
<p>When I first started implementing this data model, I initially forgot about the fact that we also have to support the Joker cards (this is not just for the sake of the example, I did actually forgot :)), this is the last thing we have to cover.</p>
<p>We could say that if both <code>Face</code> and <code>Value</code> are <code>null</code>, we consier the card a Joker, but that feels a bit hacky, let&rsquo;s introduce a boolean instead.<br>
This is the final data model, covering all use cases.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> Suit Suit { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> Face? Face { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int?</span> Value { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsJoker { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">private</span> Card(Suit suit, Face? face, <span style="color:#66d9ef">int?</span> <span style="color:#66d9ef">value</span>, <span style="color:#66d9ef">bool</span> isJoker)
    {
        Suit = suit;
        Face = face;
        Value = <span style="color:#66d9ef">value</span>;
        IsJoker = isJoker;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Card CreateFace(Suit suit, Face face)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Card(suit, face, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">false</span>);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Card CreateValue(Suit suit, <span style="color:#66d9ef">int</span> <span style="color:#66d9ef">value</span>)
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Card(suit, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">value</span>, <span style="color:#66d9ef">false</span>);
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Card CreateJoker()
    {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Card(<span style="color:#66d9ef">default</span>(Suit), <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">true</span>);
    }
}
</code></pre></div><p>I could&rsquo;ve made the <code>Suit</code> property nullable too, but I didn&rsquo;t have to, since if <code>IsJoker</code> is true, we&rsquo;ll ignore the value of <code>Suit</code> anyway. However, this this is definitely debatable, it&rsquo;s one of those things where neither approach is obviously better than the other.</p>
<h1 id="usage">Usage</h1>
<p>Let&rsquo;s see how we would use this in an application. As an example, implement the <a href="https://en.wikipedia.org/wiki/Rummy#Scoring">score calculation</a> of the card game Rummy.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">int</span> CalculateValue(Card card)
{
    <span style="color:#66d9ef">if</span>(card.IsJoker)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        
    <span style="color:#66d9ef">if</span>(card.Face.HasValue) <span style="color:#75715e">// It&#39;s a face card
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">if</span>(card.Face.Value == Face.Ace)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">15</span>;
        
        <span style="color:#66d9ef">if</span>(card.Face.Value == Face.Queen &amp;&amp; card.Suit == Suit.Spades)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">40</span>;
        
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">10</span>;
    }
    
    <span style="color:#75715e">// Now it has to be a value card
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(card.Value.Value == <span style="color:#ae81ff">10</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">10</span>;
    
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">5</span>;
}
</code></pre></div><p>It works fine, although I&rsquo;m not 100% happy with this syntax, it feels a bit awkward to do the <code>HasValue</code> check to find out what the object really represents.<br>
<em>It feels to me that the type system does not help to express our domain, we had to do it ourselves</em>, we&rsquo;ll see in the next post how this is different in F#.</p>
<h1 id="possible-improvements">Possible improvements</h1>
<h2 id="check-the-kind-of-the-card-more-conveniently">Check the <em>kind</em> of the card more conveniently</h2>
<p>In order to make usage a bit more convenient, we can introduce a new property in the <code>Card</code> type explicitly specifying the <em>kind</em> of our card. We can introduce a new enum for this purpose.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">enum</span> CardKind
{
    Value,
    Face,
    Joker
}
</code></pre></div><p>Then implement the property returning the appropriate value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> CardKind Kind
    {
        <span style="color:#66d9ef">get</span>
        {
            <span style="color:#66d9ef">if</span>(IsJoker)
                <span style="color:#66d9ef">return</span> CardKind.Joker;
            <span style="color:#66d9ef">if</span>(Face.HasValue)
                <span style="color:#66d9ef">return</span> CardKind.Face;
            <span style="color:#66d9ef">return</span> CardKind.Value;
        }
    }
    ...
}
</code></pre></div><p>This way the actual usage of the type in any given algorithm can become a bit more expressive, we can phrase it like this.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">int</span> CalculateValue(Card card)
{
    <span style="color:#66d9ef">switch</span> (card.Kind)
    {
        <span style="color:#66d9ef">case</span> CardKind.Joker:
            ...
        <span style="color:#66d9ef">case</span> CardKind.Face:
            ...
        <span style="color:#66d9ef">case</span> CardKind.Value:
            ...
    }
}
</code></pre></div><p>We can go one step further, and—since we are not using the <code>HasValue</code> property of our nullable types to determine the kind of the card—we can change our properties to return a non-nullable value.<br>
So instead of</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> Face? Face { <span style="color:#66d9ef">get</span>; }
    ...
}
</code></pre></div><p>we can do something like</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">private</span> Face? face;
    <span style="color:#66d9ef">public</span> Face Face
    {
         <span style="color:#66d9ef">get</span>
         {
             <span style="color:#66d9ef">if</span>(!face.HasValue)
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> InvalidOperationException(<span style="color:#e6db74">$&#34;You can only retrieve the Face property from a Face card. This is a {Kind} card.&#34;</span>);
             <span style="color:#66d9ef">return</span> face.Value;
         }
    }
    ...
}
</code></pre></div><p>This way in our logic using this type we can simply write <code>card.Face</code> instead of <code>card.Face.Value</code>.</p>
<p>These changes improve the &ldquo;developer experience&rdquo; of working with this data model, but keep in mind that these all introduce more and more code we have to implement, thereby increasing the complexity of our data model, giving us more chance to make mistakes. So any improvement like these is always a tradeoff.</p>
<h2 id="what-about-oo">What about OO?</h2>
<p>If we have learnt OO from a textbook, or at a university, we might have seen an introduction through examples like Hawk -&gt; Bird -&gt; Animal, or Square -&gt; Rectangle -&gt; Shape (and then later in the industry we probably heard many arguments against the validity of such examples, but let&rsquo;s put that aside for a moment :)).<br>
Now if we look at our domain, it seems to fit the same pattern, so if OO dictates creating such inheritance trees, shouldn&rsquo;t we represent the various kinds of card as classes deriving from each other? We could do the following:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span> { ... }

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FaceCard</span> : Card { ... }

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ValueCard</span> : Card { ... }

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Joker</span> : Card { ... }
</code></pre></div><p>We could definitely do this. My problem with this approach is twofold.<br>
First, it is cumbersome to actually use this model in an algorithm. We could either do a switch-case on the type of our card.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">int</span> CalculateValue(Card card)
{
    <span style="color:#66d9ef">switch</span> (card)
    {
        <span style="color:#66d9ef">case</span> Joker j:
            ...
        <span style="color:#66d9ef">case</span> FaceCard f:
            ...
        <span style="color:#66d9ef">case</span> ValueCard v:
            ...
    }
}
</code></pre></div><p>But normally this is considered an anti-pattern in object oriented programming. According to pure OO, if we have to switch case on the dynamic type of our object, we are doing something wrong. (Although this is not 100% clear, especially since the ability to do this conveniently has recently been introduced in C# in the form of pattern matching.)</p>
<p>The other way to do it would be the &ldquo;proper OO way&rdquo;, to introduce the <code>CalculateValue</code> method on the base class, and override it with the actual implementation in the derived types.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Card</span>
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">int</span> CalculateValue();
    ...
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FaceCard</span> : Card
{
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">int</span> CalculateValue()
    {
        <span style="color:#75715e">// Implementation for a face card.
</span><span style="color:#75715e"></span>        ...
    }
    ...
}
...
</code></pre></div><p>This supposed to be the textbook OO solution, however, it has a problem: with this approach we cannot achieve the goal we set out to deliver, namely to implement the data model as a self-contained unit (a separate library), on which the implementations of the various algorithms can depend. Because as we would introduce the implementation of more and more different card games, all of their logic would go into these *Card classes, thereby growing and growing them in size.<br>
This is a manifestation of one of the general arguments against OO (or specifically inheritance), that as we introduce more and more features, due to encapsulation, our OO classes tend to grow, and become large and complicated.</p>
<p>Because of these reasons I think this OO approach is not really suitable to solve our problem. The puzzle pieces of OO seemingly fall in place nicely, but this approach actually causes more problems than what it solves.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post I tried to illustrate the challenges and tough decisions we usually face when designing a data model in an object oriented language. If you have any suggestions on how to further improve this implementation, feel free to leave it as a comment!</p>
<p>In the <a href="/a-data-model-exercise-in-two-languages-part-2-f">next post</a> I&rsquo;ll look at how to solve the same problem in F#, and how can its type system eliminate some problems that are difficult to express in an OO language.</p>

    </article>

    
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https:\/\/blog.markvincze.com\/a-data-model-exercise-in-two-languages-part-1-c\/';
        
        this.page.identifier = 'ghost-37';
        
      };
      (function () { 
        var d = document, s = d.createElement('script');
        s.src = 'https://markvinczeblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  

</section>



  <div style="flex: 1"></div>

  <footer class="footer py-6">
    <div class="content has-text-centered">
      <p>
        © 2020 <strong>Mark Vincze</strong>. All rights reserved.<br />
        Built with <a href="https://gohugo.io/">Hugo</a> and <a href="https://bulma.io/">Bulma</a>. 💙
      </p>
    </div>
  </footer>

</body>

</html>