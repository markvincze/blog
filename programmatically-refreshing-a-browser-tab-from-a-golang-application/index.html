<!DOCTYPE html>
<html lang="en">

<head>
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-72523215-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-72523215-1');
  </script>

  <title>Programmatically refreshing a browser tab from a Golang application</title>

  <link rel="stylesheet" href="/styles/styles.css">
  <script defer src="https://use.fontawesome.com/releases/v5.15.1/js/all.js"></script>
  <script defer src="/scripts/scripts.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.js" data-cfasync="false"></script>
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/cookieconsent@3/build/cookieconsent.min.css" />
  <link rel="icon" href="/favicon.png" type="image/png" />

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Programmatically refreshing a browser tab from an application can be done with a WebSocket connection. This post describes how to achieve this in Golang." />
  <meta property="og:url" content="https://blog.markvincze.com/programmatically-refreshing-a-browser-tab-from-a-golang-application/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Programmatically refreshing a browser tab from a Golang application" />
  <meta property="og:description" content="Programmatically refreshing a browser tab from an application can be done with a WebSocket connection. This post describes how to achieve this in Golang." />
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mrkvincze" />
  <meta name="twitter:title" content="Programmatically refreshing a browser tab from a Golang application" />
  <meta name="twitter:description" content="Programmatically refreshing a browser tab from an application can be done with a WebSocket connection. This post describes how to achieve this in Golang." />
  

</head>

<body>
  <div class="navbar-container">
    <nav class="navbar container is-max-desktop" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarMenu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div id="navbarMenu" class="navbar-menu has-text-white-ter">

        <div class="navbar-start">
          
          <a class="navbar-item" href="/">About</a>
          
          <a class="navbar-item" href="/posts">Blog</a>
          
          <a class="navbar-item" href="/projects">Projects</a>
          
        </div>

        <div class="navbar-end pt-2 ml-2">
          <a class="icon is-medium" href="https://twitter.com/mrkvincze" target="_blank">
            <i class="fab fa-lg fa-twitter"></i>
          </a>
          <a class="icon is-medium" href="https://www.github.com/markvincze" target="_blank">
            <i class="fab fa-lg fa-github"></i>
          </a>
          <a class="icon is-medium" href="https://stackoverflow.com/users/974733/mark-vincze" target="_blank">
            <i class="fab fa-lg fa-stack-overflow"></i>
          </a>
          <a class="icon is-medium" href="https://www.linkedin.com/in/markvincze" target="_blank">
            <i class="fab fa-lg fa-linkedin"></i>
          </a>
          <a class="icon is-medium" href="/index.xml" target="_blank">
            <i class="fas fa-lg fa-rss"></i>
          </a>
        </div>
      </div>
    </nav>
  </div>

  <div class="hero-body">
    <div class="container has-text-centered">
      <a href="/">
        <h1 class="title is-2">
          Mark Vincze
        </h1>
      </a>
      <h2 class="subtitle is-5">
        Software Developer
      </h2>
    </div>
  </div>

  

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title is-1">Programmatically refreshing a browser tab from a Golang application</h1>

    
      


<p class="mb-3 is-vcentered">
  <time class="has-text-grey" datetime="2016-10-30">Oct 30, 2016 &bull;</time>

  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/golang/">golang</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/websocket/">websocket</a>
  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/livereload/">livereload</a>
  

</p>
    

    <article class="content mt-6">
      <h1 id="introduction">Introduction</h1>
<p>At work I&rsquo;ve been working on a client-side Golang application (a command-line tool), which is used as part of the development toolchain we&rsquo;re using at the company.</p>
<p>This application is used from the command line to upload packages to our development web server, which is then opened in the browser.</p>
<p>Instead of opening our development site in a new tab every time, I wanted to programmatically refresh the browser tab if one has already been opened.</p>
<p>I initially expected this to be a pretty easy task, but after some googling I had to realize it&rsquo;s not trivial at all.
Apparently, there is no way to programmatically connect to the browser, query the list of tabs open, find a particular tab, and refresh it. (Especially not in a cross-browser and cross-platform way.)</p>
<p>After searching and asking around, I was pointed to a technology called livereload, which is both a <a href="http://livereload.com/">development tool</a> and an <a href="https://www.npmjs.com/package/livereload">npm package</a> for automatically refreshing the browser when editing some HTML content, or when new HTML content is being generated during the developing a website.</p>
<p>The way livereload works is that a component is hosting a small WebSocket service to which the browser can connect. It is also running a file watcher watching all the content (HTML, CSS, JavaScript, etc.) which should trigger a browser refresh when changed.
Then a small piece of JavaScript code in the browser connects to the WebSocket server, and refreshes the tab every time it receives a message.</p>
<p>The feature I wanted to implement is a bit different: I don&rsquo;t want to watch a particular folder containing some files and refresh the browser on changes. What I want to do is be able to programmatically trigger a refresh from code.</p>
<p>It turned out there is no simpler way to achieve this than to utilize the same approach which is used by <code>livereload</code>: host a small WebSocket endpoint in my Golang app, connect to it from the browser, and send a message every time I want to refresh the page.</p>
<p>Implementing this in Golang ended up being not too difficult, although there are a couple of gotchas you have to watch out for if your site is served over HTTPS.</p>
<h1 id="implementing-the-reload-server">Implementing the reload server</h1>
<p>The Websocket service we want to implement is very simple: the client (the browser) never initiates communication, it&rsquo;s only the server (the Golang app) that sends a message when the page has to be refreshed. We need only a single message type (with no arguments), since the only action we want to implement is the reload.</p>
<p>The library <a href="https://github.com/gorilla/websocket"><code>websocket</code></a> from the <a href="http://www.gorillatoolkit.org/">Gorilla web toolkit</a> can be used to implement the endpoint. I based my implementation on the <a href="https://github.com/gorilla/websocket/tree/master/examples/chat">Chat example</a> provided by the library (basically I tried to trim it down as much as possible, so it only contains the parts necessary for my purposes).</p>
<p>To host a WebSocket endpoint, we need to have some boilerplate to manage the client connections and to send messages. I took the following two files from the <a href="https://github.com/gorilla/websocket/tree/master/examples/chat">Chat example</a> without much modification.</p>
<p>The first helper file is <code>wsClient.go</code>, which is responsible for the low level WebSocket communication.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;log&#34;</span>
    <span style="color:#e6db74">&#34;net/http&#34;</span>
    <span style="color:#e6db74">&#34;time&#34;</span>

    <span style="color:#e6db74">&#34;github.com/gorilla/websocket&#34;</span>
)

<span style="color:#66d9ef">const</span> (
    <span style="color:#75715e">// Time allowed to write a message to the peer.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">writeWait</span> = <span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>

    <span style="color:#75715e">// Time allowed to read the next pong message from the peer.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pongWait</span> = <span style="color:#ae81ff">60</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Second</span>

    <span style="color:#75715e">// Send pings to peer with this period. Must be less than pongWait.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pingPeriod</span> = (<span style="color:#a6e22e">pongWait</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">9</span>) <span style="color:#f92672">/</span> <span style="color:#ae81ff">10</span>
)

<span style="color:#66d9ef">var</span> (
    <span style="color:#a6e22e">newline</span> = []<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;\n&#39;</span>}
    <span style="color:#a6e22e">space</span>   = []<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39; &#39;</span>}
)

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">upgrader</span> = <span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">Upgrader</span>{
    <span style="color:#a6e22e">ReadBufferSize</span>:  <span style="color:#ae81ff">1024</span>,
    <span style="color:#a6e22e">WriteBufferSize</span>: <span style="color:#ae81ff">1024</span>,
    <span style="color:#a6e22e">CheckOrigin</span>: <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">bool</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
    },
}

<span style="color:#75715e">// Client is an middleman between the websocket connection and the hub.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Client</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">hub</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Hub</span>

    <span style="color:#75715e">// The websocket connection.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">conn</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">Conn</span>

    <span style="color:#75715e">// Buffered channel of outbound messages.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">send</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>
}

<span style="color:#75715e">// readPump pumps messages from the websocket connection to the hub.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>) <span style="color:#a6e22e">readPump</span>() {
    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">hub</span>.<span style="color:#a6e22e">unregister</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
    }()
    <span style="color:#66d9ef">for</span> {
        <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">ReadMessage</span>()
        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">IsUnexpectedCloseError</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">CloseGoingAway</span>) {
                <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;An error happened when reading from the Websocket client: %v&#34;</span>, <span style="color:#a6e22e">err</span>)
            }
            <span style="color:#66d9ef">break</span>
        }
    }
}

<span style="color:#75715e">// write writes a message with the given message type and payload.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>) <span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">mt</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">payload</span> []<span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span> {
    <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">SetWriteDeadline</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">writeWait</span>))
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">WriteMessage</span>(<span style="color:#a6e22e">mt</span>, <span style="color:#a6e22e">payload</span>)
}

<span style="color:#75715e">// writePump pumps messages from the hub to the websocket connection.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>) <span style="color:#a6e22e">writePump</span>() {
    <span style="color:#a6e22e">ticker</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">NewTicker</span>(<span style="color:#a6e22e">pingPeriod</span>)
    <span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
        <span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">Stop</span>()
        <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">Close</span>()
    }()
    <span style="color:#66d9ef">for</span> {
        <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">message</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">send</span>:
            <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
                <span style="color:#75715e">// The hub closed the channel.
</span><span style="color:#75715e"></span>                <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">CloseMessage</span>, []<span style="color:#66d9ef">byte</span>{})
                <span style="color:#66d9ef">return</span>
            }

            <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">SetWriteDeadline</span>(<span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>().<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">writeWait</span>))
            <span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">NextWriter</span>(<span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">TextMessage</span>)
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                <span style="color:#66d9ef">return</span>
            }
            <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">message</span>)

            <span style="color:#a6e22e">n</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">send</span>)
            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">n</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
                <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">newline</span>)
                <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">send</span>)
            }

            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Close</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                <span style="color:#66d9ef">return</span>
            }
        <span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ticker</span>.<span style="color:#a6e22e">C</span>:
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">websocket</span>.<span style="color:#a6e22e">PingMessage</span>, []<span style="color:#66d9ef">byte</span>{}); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
                <span style="color:#66d9ef">return</span>
            }
        }
    }
}

<span style="color:#75715e">// serveWs handles websocket requests from the peer.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">serveWs</span>(<span style="color:#a6e22e">hub</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Hub</span>, <span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
    <span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">upgrader</span>.<span style="color:#a6e22e">Upgrade</span>(<span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>, <span style="color:#66d9ef">nil</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
        <span style="color:#66d9ef">return</span>
    }
    <span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Client</span>{<span style="color:#a6e22e">hub</span>: <span style="color:#a6e22e">hub</span>, <span style="color:#a6e22e">conn</span>: <span style="color:#a6e22e">conn</span>, <span style="color:#a6e22e">send</span>: make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">256</span>)}
    <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">hub</span>.<span style="color:#a6e22e">register</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">client</span>
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">writePump</span>()
    <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">readPump</span>()
}
</code></pre></div><p>Since this was originally implemented to support the two-way communication in a Chat application, probably it could be trimmed down even more.
The second file, <code>wsHub.go</code> takes care of managing the list of client connections.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#75715e">// Hub maintains the set of active clients and broadcasts messages to the clients.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Hub</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#75715e">// Registered clients.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">clients</span> <span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>]<span style="color:#66d9ef">bool</span>

    <span style="color:#75715e">// Inbound messages from the clients.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">broadcast</span> <span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>

    <span style="color:#75715e">// Register requests from the clients.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">register</span> <span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>

    <span style="color:#75715e">// Unregister requests from clients.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">unregister</span> <span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newHub</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Hub</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Hub</span>{
        <span style="color:#a6e22e">broadcast</span>:  make(<span style="color:#66d9ef">chan</span> []<span style="color:#66d9ef">byte</span>),
        <span style="color:#a6e22e">register</span>:   make(<span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>),
        <span style="color:#a6e22e">unregister</span>: make(<span style="color:#66d9ef">chan</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>),
        <span style="color:#a6e22e">clients</span>:    make(<span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">Client</span>]<span style="color:#66d9ef">bool</span>),
    }
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Hub</span>) <span style="color:#a6e22e">run</span>() {
    <span style="color:#66d9ef">for</span> {
        <span style="color:#66d9ef">select</span> {
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">register</span>:
            <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">clients</span>[<span style="color:#a6e22e">client</span>] = <span style="color:#66d9ef">true</span>
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">unregister</span>:
            <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">clients</span>[<span style="color:#a6e22e">client</span>]; <span style="color:#a6e22e">ok</span> {
                delete(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">clients</span>, <span style="color:#a6e22e">client</span>)
                close(<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">send</span>)
            }
        <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">broadcast</span>:
            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">client</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">clients</span> {
                <span style="color:#66d9ef">select</span> {
                <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">send</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>:
                <span style="color:#66d9ef">default</span>:
                    close(<span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">send</span>)
                    delete(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">clients</span>, <span style="color:#a6e22e">client</span>)
                }
            }
        }
    }
}
</code></pre></div><p>With these helpers in place we can start up our actual WS endpoint.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;bytes&#34;</span>
    <span style="color:#e6db74">&#34;io/ioutil&#34;</span>
    <span style="color:#e6db74">&#34;log&#34;</span>
    <span style="color:#e6db74">&#34;net/http&#34;</span>
)

<span style="color:#66d9ef">var</span> (
    <span style="color:#a6e22e">hub</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Hub</span>
    <span style="color:#75715e">// The port on which we are hosting the reload server has to be hardcoded on the client-side too.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">reloadAddress</span>    = <span style="color:#e6db74">&#34;:12450&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startReloadServer</span>() {
    <span style="color:#a6e22e">hub</span> = <span style="color:#a6e22e">newHub</span>()
    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">hub</span>.<span style="color:#a6e22e">run</span>()
    <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">HandleFunc</span>(<span style="color:#e6db74">&#34;/reload&#34;</span>, <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
        <span style="color:#a6e22e">serveWs</span>(<span style="color:#a6e22e">hub</span>, <span style="color:#a6e22e">w</span>, <span style="color:#a6e22e">r</span>)
    })

    <span style="color:#66d9ef">go</span> <span style="color:#a6e22e">startServer</span>()
    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Reload server listening at&#34;</span>, <span style="color:#a6e22e">reloadAddress</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">startServer</span>() {
    <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#a6e22e">reloadAddress</span>, <span style="color:#66d9ef">nil</span>)

    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Failed to start up the Reload server: &#34;</span>, <span style="color:#a6e22e">err</span>)
        <span style="color:#66d9ef">return</span>
    }
}
</code></pre></div><p>In this example I&rsquo;m hosting the service on the port <code>12450</code>, which I randomly picked from the unassigned ports in the <a href="http://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?&amp;page=1">registry maintained by IANA</a>. You can pick another port for your application, which can then be hardcoded into both the service and the client.</p>
<p>Calling the function <code>startReloadServer</code> at the beginning of our application will start hosting the WebSocket endpoint, and it&rsquo;ll keep running until our app terminates.</p>
<p>Then we can implement the function that will send the reload message to the browser. This is the function we have to call when we want to reload the browser.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">sendReload</span>() {
    <span style="color:#a6e22e">message</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">TrimSpace</span>([]byte(<span style="color:#e6db74">&#34;reload&#34;</span>))
    <span style="color:#a6e22e">hub</span>.<span style="color:#a6e22e">broadcast</span> <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">message</span>
}
</code></pre></div><p>In the example I&rsquo;m sending the string <code>&quot;reload&quot;</code>, which doesn&rsquo;t have any role, the client won&rsquo;t interpret it at all, since the only function we have is reloading, which doesn&rsquo;t need any parameters. If we needed anything more complicated, here we could send an arbitrary message to the browser, which we can then process in JavaScript.</p>
<p>With all these building blocks in place the only thing we have to do is call <code>startReloadServer</code> to start hosting the service, and then call <code>sendReload</code> every time we want to refresh the browser.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">startReloadServer</span>()

<span style="color:#f92672">...</span>

<span style="color:#a6e22e">sendReload</span>()
</code></pre></div><h1 id="connecting-to-the-reload-service">Connecting to the Reload service</h1>
<p>Connecting the website to the endpoint is pretty simple, but we have to keep in mind that when we open the site in the browser, our app hosting the endpoint might not run yet (or it might be stopped and restarted later). So if our site cannot connect initially, we need to periodically retry.</p>
<p>This can be done with the following code.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">tryConnectToReload</span>(<span style="color:#a6e22e">address</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">conn</span>;
  <span style="color:#75715e">// This is a statically defined port on which the app is hosting the reload service.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">conn</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebSocket</span>(<span style="color:#e6db74">&#34;ws://localhost:12450/reload&#34;</span>);

  <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">onclose</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">evt</span>) {
    <span style="color:#75715e">// The reload endpoint hasn&#39;t been started yet, we are retrying in 2 seconds.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setTimeout</span>(() =&gt; <span style="color:#a6e22e">tryConnectToReload</span>(), <span style="color:#ae81ff">2000</span>);
  };

  <span style="color:#a6e22e">conn</span>.<span style="color:#a6e22e">onmessage</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">evt</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Refresh received!&#34;</span>);

    <span style="color:#75715e">// If we uncomment this line, then the page will refresh every time a message is received.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//location.reload()
</span><span style="color:#75715e"></span>  };
}

<span style="color:#66d9ef">try</span> {
  <span style="color:#66d9ef">if</span> (window[<span style="color:#e6db74">&#34;WebSocket&#34;</span>]) {
    <span style="color:#a6e22e">tryConnectToReload</span>();
  } <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;Your browser does not support WebSocket, cannot connect to the reload service.&#34;</span>);
  }
} <span style="color:#66d9ef">catch</span> (<span style="color:#a6e22e">ex</span>) {
  <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;Exception during connecting to reload:&#39;</span>, <span style="color:#a6e22e">ex</span>);
}
</code></pre></div><p>So if we call <code>location.reload()</code> in the <code>onmessage</code> handler, then the browser will be refreshed every time we receive a message.</p>
<h1 id="problems-with-tls">Problems with TLS</h1>
<p>The above solution works perfectly as long as our website is served over plain HTTP.
This is typically the case if it&rsquo;s a site under development hosted on <code>localhost</code>.</p>
<p>On the other hand, if we access the site through HTTPS, things are a bit more tricky.</p>
<p>If we try to connect from a website served over HTTPS to a WebSocket endpoint hosted without TLS (over <code>ws://</code>), then â€” depending on the browser and the operating system â€” we might get the following error.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-plain" data-lang="plain">startReload.js:24 Mixed Content: The page at &#39;https://my-dev-application.com/&#39; was loaded over HTTPS, but attempted to connect to the insecure WebSocket endpoint &#39;ws://localhost:12450/reload&#39;. This request has been blocked; this endpoint must be available over WSS.
</code></pre></div><p>I didn&rsquo;t find any overview about exactly which browsers and systems produce this error. Based on my tests, this problem occurs for Chrome on Linux, but not on Windows nor OSX, and it also happens for Firefox, on every operating system I tried.</p>
<p>I couldn&rsquo;t find a perfect solution to the problem, but there is a workaround that can at least mitigate the issue. What we can do is host the WebSocket endpoint on both <code>ws</code> and <code>wss</code>, and try to connect to both from the client (first to <code>ws</code>, and if that fails, then to <code>wss</code>).</p>
<p>This solves the problem for both Chrome and Firefox, but there is one more thing we have to do. Since we are hosting the service on localhost, there is no way to get a valid SSL certificate, and Chrome rejects the connection by default. In order to make it ignore certificate errors when connecting to <code>localhost</code>, we have to go to the advanced settings page in Chrome by navigating to <code>chrome://flags</code>, and we have to enable the following setting.</p>
<p><img src="/images/2016/10/chrome-ignore-localhost-cert.png" alt=""  style="display:block; margin: auto;" /></p>
<p>With Firefox this didn&rsquo;t cause a problem, the connection worked properly after I started hosting the endpoint on <code>wss</code>. I&rsquo;ll update the post if I encounter any problem with it.</p>
<h1 id="source">Source</h1>
<p>I uploaded the full working example to <a href="https://github.com/markvincze/golang-reload-browser">GitHub</a>, which also contain the implementation of hosting the reload endpoint on both WS and WSS, and also the code for the client side to establish the connection.</p>

    </article>

    
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https:\/\/blog.markvincze.com\/programmatically-refreshing-a-browser-tab-from-a-golang-application\/';
        
        this.page.identifier = 'ghost-26';
        
      };
      (function () { 
        var d = document, s = d.createElement('script');
        s.src = 'https://markvinczeblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
  

</section>



  <div style="flex: 1"></div>

  <footer class="footer py-6">
    <div class="content has-text-centered">
      <p>
        Â© 2020 <strong>Mark Vincze</strong>. All rights reserved.<br />
        Built with <a href="https://gohugo.io/">Hugo</a> and <a href="https://bulma.io/">Bulma</a>. ðŸ’™
      </p>
    </div>
  </footer>

</body>

</html>