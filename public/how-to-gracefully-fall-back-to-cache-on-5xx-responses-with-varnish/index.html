<!DOCTYPE html>
<html>

<head>
  <title>How to gracefully fall back to cache on 5xx responses with Varnish</title>

  
  <link rel="stylesheet" href="/styles/bulma.css">
  <script defer src="https://use.fontawesome.com/releases/v5.15.1/js/all.js"></script>
  <script defer src="/scripts/scripts.js"></script>
  <link rel="icon" href="/favicon.png" type="image/png" />

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Varnish can gracefully fall  back to cached values in case our backend is down. This post describes how we can handle 5xx errors this way." />
  <meta property="og:url" content="https://blog.markvincze.com/how-to-gracefully-fall-back-to-cache-on-5xx-responses-with-varnish/" />
  <meta property="og:type" content="article" />
  <meta property="og:title" content="How to gracefully fall back to cache on 5xx responses with Varnish" />
  <meta property="og:description" content="Varnish can gracefully fall  back to cached values in case our backend is down. This post describes how we can handle 5xx errors this way." />
  
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:site" content="@mrkvincze" />
  <meta name="twitter:title" content="How to gracefully fall back to cache on 5xx responses with Varnish" />
  <meta name="twitter:description" content="Varnish can gracefully fall  back to cached values in case our backend is down. This post describes how we can handle 5xx errors this way." />
  

</head>

<body>
  <div class="navbar-container">
    <nav class="navbar container is-max-desktop" role="navigation" aria-label="main navigation">
      <div class="navbar-brand">

        <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarMenu">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div id="navbarMenu" class="navbar-menu">
        <div class="navbar-start">
          <a class="navbar-item" href="/">
            Home
          </a>

          <a class="navbar-item" href="/posts">
            Blog
          </a>

          <a class="navbar-item">
            Presentations
          </a>
        </div>
        <div class="navbar-end pt-2 ml-2">
          <a class="icon is-medium" href="https://twitter.com/mrkvincze">
            <i class="fab fa-lg fa-twitter"></i>
          </a>
          <a class="icon is-medium" href="https://www.github.com/markvincze">
            <i class="fab fa-lg fa-github"></i>
          </a>
          <a class="icon is-medium" href="https://stackoverflow.com/users/974733/mark-vincze">
            <i class="fab fa-lg fa-stack-overflow"></i>
          </a>
          <a class="icon is-medium" href="https://www.linkedin.com/in/markvincze">
            <i class="fab fa-lg fa-linkedin"></i>
          </a>
          <a class="icon is-medium" href="/index.xml">
            <i class="fas fa-lg fa-rss"></i>
          </a>
        </div>
      </div>
    </nav>
  </div>

  <div class="hero-body">
    <div class="container has-text-centered">
      <a href="/">
        <h1 class="title is-1">
          Mark Vincze
        </h1>
      </a>
      <h2 class="subtitle is-4">
        Software Developer
      </h2>
    </div>
  </div>

  

<section class="section">
  <div class="container is-max-desktop">
    <h1 class="title is-1">How to gracefully fall back to cache on 5xx responses with Varnish</h1>
    


<p class="mb-3 is-vcentered">
  <time class="has-text-grey" datetime="2018-07-28">Jul 28, 2018 &bull;</time>

  
  
  <a class="button is-link is-light is-primary is-small p-2 mr-1 is-uppercase has-text-weight-semibold" style="height: 2em; margin-top: 0.1em" href="https://blog.markvincze.com/tags/varnish">varnish</a>
  

</p>
    <article class="content mt-6">
      <h1 id="introduction">Introduction</h1>
<p>Varnish is a widely used reverse proxy and <em>HTTP accelerator</em>. It sits in front of an HTTP service, and caches the responses to improve the response times observed by the clients, and possibly to reduce the load on the upstream backend service.</p>
<p>Besides bringing performance improvements, Varnish can be also useful for shielding the clients from any outage of the backend service, since if the upstream is temporarily out of service, Varnish can keep serving the cached content, so the clients don&rsquo;t have to notice anything (if the data they need is already present in the cache).</p>
<p>In order to use the basic caching capability, and to also gracefully fall back when the backend is down, we have to control two properties of the response object.</p>
<ul>
<li><code>beresp.ttl</code>: This is the amount of time until Varnish keeps an object in cache, and serves it up from there to the clients until it tries to fetch it again from the upstream.</li>
<li><code>beresp.grace</code>: This is the amount of time an object is kept in the cache even after the ttl is expired. This is interpreted on top of the ttl, so for example if both <code>ttl</code> and <code>grace</code> is set to <code>1m</code>, then the objects can stay in the cache for a total of 2 minutes.</li>
</ul>
<p>If a request comes in for which the response is already in the cache, and the <code>ttl</code> has not passed yet, then Varnish returns the cached value to the client without trying to fetch a fresh one from the backend.</p>
<p>On the first request that comes after <code>ttl</code> expired, if <code>grace</code> is set and is not expired yet, then Varnish will immediately return the cached value to the client, and at the same time it will trigger a background fetch for a fresh response. If the fetch is successful, it replaces the stale object in the cache with the fresh one.</p>
<p><img src="/images/2018/07/happy-flow.png" alt="Sequence diagram showing how Varnish returns the cached content to the clients."></p>
<p>This behavior means that if the backend is not available, that won&rsquo;t affect the end clients until the end of the <code>grace</code> period, since Varnish will always return the cached object to the client, and only do a background fetch asynchronously. Which will fail if the backend is down, but that won&rsquo;t hurt the object already stored in the cache.<br>
And if the <code>grace</code> period is over, Varnish will purge the cached object, and won&rsquo;t return it to clients any more. So if the backend is down, the clients will receive a <code>503 Service Unavailable</code> response from Varnish.</p>
<p><img src="/images/2018/07/backend-down.png" alt="Sequence diagram showing how Varnish behaves when the backend is down during the grace period."></p>
<p>In practice, <code>grace</code> can be much longer than <code>ttl</code>. For example we can set <code>ttl</code> to a couple of minutes to make sure the clients regularly get fresh data, but we can set <code>grace</code> to multiple hours, to give us time to fix the backend in case of an outage.</p>
<h1 id="5xx-responses">5xx responses</h1>
<p>By default Varnish only falls back to the cached values during the grace period if the backend can&rsquo;t be connected to, or if the request times out. If the backend returns a <code>5xx</code> error, Varnish considers that normal response, and returns it to the client (it might even store it in the cache, depending on our configuration).<br>
This is an understandable default, it might be confusing if our clients did not receive some server errors which could contain valuable information about the problem with the backend.</p>
<p>On the other hand, we might also consider 5xx responses outages, and want to gracefully fall back to the cached values instead. I wanted to achieve the following objectives.</p>
<ul>
<li>Never cache <code>5xx</code> responses. This is important, because this&rsquo;ll make Varnish try to fetch the response again upon every request. (It would be wasteful to cache a <code>500</code> response for 10 minutes, when the outage might only last 1-2 minutes.)</li>
<li>If we are in the grace period, and the backend returns a <code>5xx</code>, fall back to the cached response and send that to the client.</li>
<li>If we don&rsquo;t have the response in the cache at all, then return to the client the actual <code>5xx</code> error that was given by the backend.</li>
</ul>
<p>This can be achieved with Varnish pretty easily, but it needs some configuration.</p>
<h1 id="configuration">Configuration</h1>
<p>In order to customize the behavior of Varnish, we have to edit its configuration file (which usually resides at <code>/etc/varnish/default.vcl</code>).</p>
<p>The config file is using the VCL syntax, which is a C-like domain specific language specifically for the customization of Varnish. It took me some getting used to before I could wrap my head around it, an actual production configuration can get complicated, which can be a bit intimidating at first. In this post I won&rsquo;t talk about the basics, but will just rather show the bits necessary for this particular setup. If you&rsquo;d like to learn the basics of VCL, I recommend reading a comprehensive guide, for example <a href="https://info.varnish-software.com/the-varnish-book">The Varnish Book</a>.</p>
<p>In the VCL configuration we can customize various <em>subroutines</em>, with which we can hook into varios steps of the request lifecycle. The only subrouting we&rsquo;re going to look at is <code>sub vcl_backend_response</code>, which is triggered right after a response was received from the backend.</p>
<p>A very simple version of this would be the following, which enables caching for 1 minute, and enables graceful fallback for 10 minutes on top of that.</p>
<pre><code>sub vcl_backend_response {
    set beresp.ttl = 1m;
    set beresp.grace = 10m;
}
</code></pre><p>In order to achieve the objective of gracefull fallback on <code>5xx</code> errors, we&rsquo;ll need to use the following additional tools.</p>
<ul>
<li><code>beresp.status</code>: With this we can check the status code returned by the backend. This will be used to handle <code>5xx</code> responses specially.</li>
<li><code>bereq.is_bgfetch</code>: This field shows whether this was a backend request sent asynchronously when the client received a response already from the cache, or if it&rsquo;s a synchronous request that was sent when we didn&rsquo;t find the response in the cache.</li>
<li><code>beresp.uncacheable</code>: We can set this to true to prevent a response from being cached.</li>
<li><code>abandon</code>: This is a <em>return keyword</em> that we can use to make Varnish completely abandon the request, and return a <em>synthesized</em> <code>503</code> to the client (or just do nothing, in case of an asynchronous background fetch).</li>
</ul>
<p>With all these tools in our belt we can implement the requirements with the following logic.</p>
<pre><code>sub vcl_backend_response {
    set beresp.ttl = 1m;
    set beresp.grace = 10m;

    # This block will make sure that if the upstream returns a 5xx, but we have the response in the cache (even if it's expired),
    # we fall back to the cached value (until the grace period is over).
    if (beresp.status == 500 || beresp.status == 502 || beresp.status == 503 || beresp.status == 504)
    {
        # This check is important. If is_bgfetch is true, it means that we've found and returned the cached object to the client,
        # and triggered an asynchoronus background update. In that case, if it was a 5xx, we have to abandon, otherwise the previously cached object
        # would be erased from the cache (even if we set uncacheable to true).
        if (bereq.is_bgfetch)
        {
            return (abandon);
        }

        # We should never cache a 5xx response.
        set beresp.uncacheable = true;
    }
}
</code></pre><p>In the above code I&rsquo;m only handling the standard <code>500</code>, <code>502</code>, <code>503</code> and <code>504</code> codes, but of course you can extend it if your backend is returning something else.</p>
<p>The key of the solution is using <code>abandon</code> in combination with <code>if (bereq.is_bgfetch)</code>. If we returned <code>abandon</code> on every <code>5xx</code> without checking <code>bereq.is_bgfetch</code>, then Varnish would always return its built-in <code>503</code> response to the client instead of the <code>5xx</code> sent by the backend, so our client could never see the actual backend errors.</p>
<p><strong>Important</strong>: The field <code>bereq.is_bgfetch</code> is only available starting from Varnish 5.2.0. And depending on our OS version and installation method, we might be on an earlier version, so this is important to check with <code>varnishd -V</code>.</p>
<p>The configuration syntax of Varnish takes a bit of getting used to, but if set up properly, it provides an invaluable tool for improving the performance of our services, and meanwhile protecting our clients from outages. And I hope this post will be helpful when handling server side errors.</p>

    </article>

    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function () {
        this.page.url = 'https:\/\/blog.markvincze.com\/how-to-gracefully-fall-back-to-cache-on-5xx-responses-with-varnish\/';
        
        this.page.identifier = 'ghost-5b5c8545e67a0c102087288f';
        
      };
      (function () { 
        var d = document, s = d.createElement('script');
        s.src = 'https://markvinczeblog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>



  <footer class="footer py-6">
    <div class="content has-text-centered">
      <p>
        © 2020 <strong>Mark Vincze</strong>. All rights reserved.<br />
        Built with <a href="https://gohugo.io/">Hugo</a> and <a href="https://bulma.io/">Bulma</a>. 💙
      </p>
    </div>
  </footer>

</body>

</html>