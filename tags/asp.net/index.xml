<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>asp.net on Mark Vincze</title>
    <link>https://markvincze.github.io/blog/tags/asp.net/</link>
    <description>Recent content in asp.net on Mark Vincze</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Feb 2017 17:38:02 +0000</lastBuildDate><atom:link href="https://markvincze.github.io/blog/tags/asp.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Jumpstart F# web development: F# with ASP.NET on classic .NET</title>
      <link>https://markvincze.github.io/blog/jumpstart-f-web-development-f-with-asp-net-on-classic-net/</link>
      <pubDate>Sun, 05 Feb 2017 17:38:02 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/jumpstart-f-web-development-f-with-asp-net-on-classic-net/</guid>
      <description>The first part of my series about jumstarting F# web development takes a look at probably the most straightforward-looking approach: write F# code using ASP.NET on the classic (full) .NET Framework. (If you&amp;rsquo;re not familiar with the distinction between the full .NET and .NET Core, you can read about it here.)
Traditionally, the ASP.NET development workflow has been a very streamlined and convenient experience. If we&amp;rsquo;re using C# and develop web applications with ASP.</description>
    </item>
    
    <item>
      <title>Series: Jumpstart F# web development</title>
      <link>https://markvincze.github.io/blog/series-jumpstart-f-web-development/</link>
      <pubDate>Sun, 05 Feb 2017 17:35:00 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/series-jumpstart-f-web-development/</guid>
      <description>F# is a functional first general purpose programming language targeting the .NET Framework. Since .NET is a framework commonly used for web development (most often with C# and ASP.NET). And if we would like to do web development on the .NET framework in a more functional style, using F# is the logical choice.
F# is a language loved by its community, which is actively working on improving its tooling and creating its own ecosystem.</description>
    </item>
    
    <item>
      <title>Matching route templates manually in ASP.NET Core</title>
      <link>https://markvincze.github.io/blog/matching-route-templates-manually-in-asp-net-core/</link>
      <pubDate>Sat, 18 Jun 2016 21:17:15 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/matching-route-templates-manually-in-asp-net-core/</guid>
      <description>We can use routing in ASP.NET to define paths on which we want to respond to HTTP requests. In ASP.NET Core we have two common ways to specify routing in our application.
We can use the Route attribute on the action methods:
[HttpGet(&amp;#34;test/{myParam}&amp;#34;] public IActionResult Get(int myParam) { // ... } Or if we don&amp;rsquo;t want to use MVC, we can directly set up some responses in our Startup class by creating a RouteBuilder and adding it to the pipeline with the UseRouter method.</description>
    </item>
    
    <item>
      <title>Stubbing service dependencies in .NET using Stubbery</title>
      <link>https://markvincze.github.io/blog/stubbing-service-dependencies-in-net-using-stubbery/</link>
      <pubDate>Sun, 12 Jun 2016 15:27:28 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/stubbing-service-dependencies-in-net-using-stubbery/</guid>
      <description>Introduction When writing integration tests for a service (especially if we are running a long, end-to-end test), it often causes a problem that the external dependencies of our service fail.
Let&amp;rsquo;s say we have a service handling customer payments and the actual payments are handled by an external provider.
Very often, we cannot use the actual production system of our external dependency. For example, when we want to test payments, we cannot make real purchases every time we run our integration test suite.</description>
    </item>
    
    <item>
      <title>How to validate action parameters with DataAnnotation attributes?</title>
      <link>https://markvincze.github.io/blog/how-to-validate-action-parameters-with-dataannotation-attributes/</link>
      <pubDate>Sun, 28 Feb 2016 14:23:00 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/how-to-validate-action-parameters-with-dataannotation-attributes/</guid>
      <description>Model validation in MVC In both MVC and Web Api we can use the attributes provided in the System.ComponentModel.DataAnnotations namespace to specify validation rules for our models.
Let&amp;rsquo;s say we have a controller action with the following signature, accepting a single parameter populated from the request body.
public IActionResult Post([FromBody]Product product); And we decorated our Product type with the following validation attributes (example taken from the official ASP.NET documentation).
public class Product { public int Id { get; set; } [Required] public string Name { get; set; } public decimal Price { get; set; } [Range(0, 999)] public double Weight { get; set; } } When we call our endpoint by posting a product object in the body of our request, the framework is going to evaluate our validation attributes during the model binding process, and save its result (with possibly errors) in the ModelState property of our controller.</description>
    </item>
    
    <item>
      <title>ASP.NET Core 1.0: hints to get started</title>
      <link>https://markvincze.github.io/blog/getting-started-with-asp-net-core-1-0-tips-and-tricks/</link>
      <pubDate>Sun, 14 Feb 2016 16:30:58 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/getting-started-with-asp-net-core-1-0-tips-and-tricks/</guid>
      <description>I recently started working on implementing a Web Api application using ASP.NET Core 1.0, running it on Linux with the CoreCLR.
There have been many changes introduced in this new version of ASP.NET, and there are also differences in how we are running and deploying applications using CoreCLR, so I&amp;rsquo;m going to document a couple of things you might encounter if you get started with using this new ecosystem.
Version numbers It is quite easy to get lost in the sea of different products and version numbers.</description>
    </item>
    
    <item>
      <title>Use Glimpse with ASP.NET Web Api</title>
      <link>https://markvincze.github.io/blog/use-glimpse-with-asp-net-web-api/</link>
      <pubDate>Thu, 14 May 2015 12:56:50 +0000</pubDate>
      
      <guid>https://markvincze.github.io/blog/use-glimpse-with-asp-net-web-api/</guid>
      <description>Glimpse is a wonderful tool for getting an insight into the mechanisms happening in an ASP.NET application. It inspects every request processed by our app, and displays its UI either embedded into our web site, or on a standalone page at a different URL.
The current version of Glimpse (1.9.2 at the time of writing this) only has proper support for ASP.NET Web Forms and MVC, and not for the Web Api.</description>
    </item>
    
  </channel>
</rss>
